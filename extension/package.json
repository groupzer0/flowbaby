{
  "name": "flowbaby",
  "displayName": "Flowbaby",
  "description": "Automatic memory for GitHub Copilot chat",
  "version": "0.5.13",
  "publisher": "Flowbaby",
  "icon": "media/flowbaby-icon-tightcrop.png",
  "engines": {
    "vscode": "^1.106.0"
  },
  "categories": [
    "AI",
    "Chat",
    "Other"
  ],
  "screenshots": [
    {
      "path": "media/auto-search.png",
      "caption": "Automatic context search"
    },
    {
      "path": "media/auto-store.png",
      "caption": "Automatic memory storage"
    },
    {
      "path": "media/interactive-chat-participant.png",
      "caption": "Interactive @flowbaby chat participant"
    },
    {
      "path": "media/manual-store-summary.png",
      "caption": "Manual memory capture via command palette"
    }
  ],
  "keywords": [
    "flowbaby",
    "copilot",
    "github copilot",
    "chat",
    "memory",
    "workspace memory",
    "knowledge graph",
    "llm",
    "context",
    "retrieval",
    "rags",
    "agent",
    "vs code",
    "developer productivity"
  ],
  "activationEvents": [
    "onStartupFinished",
    "onLanguageModelTool:flowbaby_storeMemory"
  ],
  "main": "./dist/extension.js",
  "contributes": {
    "commands": [
      {
        "command": "Flowbaby.captureMessage",
        "title": "Flowbaby: Capture to Memory",
        "category": "Flowbaby"
      },
      {
        "command": "Flowbaby.toggleMemory",
        "title": "Flowbaby: Toggle Memory",
        "category": "Flowbaby"
      },
      {
        "command": "Flowbaby.clearMemory",
        "title": "Flowbaby: Clear Workspace Memory",
        "category": "Flowbaby"
      },
      {
        "command": "Flowbaby.ingestForAgent",
        "title": "Flowbaby: Ingest Summary for Agent",
        "category": "Flowbaby",
        "enablement": "Flowbaby.enabled"
      },
      {
        "command": "Flowbaby.retrieveForAgent",
        "title": "Flowbaby: Retrieve Context for Agent",
        "category": "Flowbaby",
        "enablement": "Flowbaby.enabled"
      },
      {
        "command": "Flowbaby.backgroundStatus",
        "title": "Flowbaby: View Background Operations",
        "category": "Flowbaby"
      },
      {
        "command": "Flowbaby.showStatus",
        "title": "Flowbaby: Show Status",
        "category": "Flowbaby"
      },
      {
        "command": "Flowbaby.openDocs",
        "title": "Flowbaby: Open Documentation",
        "category": "Flowbaby"
      },
      {
        "command": "Flowbaby.validateMemories",
        "title": "Flowbaby: Validate Memories",
        "category": "Flowbaby"
      },
      {
        "command": "Flowbaby.listMemories",
        "title": "Flowbaby: List Memories",
        "category": "Flowbaby"
      },
      {
        "command": "Flowbaby.refreshDependencies",
        "title": "Flowbaby: Refresh Bridge Dependencies",
        "category": "Flowbaby"
      },
      {
        "command": "Flowbaby.initializeWorkspace",
        "title": "Flowbaby: Initialize Workspace",
        "category": "Flowbaby"
      },
      {
        "command": "Flowbaby.setupEnvironment",
        "title": "Flowbaby: Setup Environment (Legacy)",
        "category": "Flowbaby"
      },
      {
        "command": "Flowbaby.configureApiKey",
        "title": "Flowbaby: Configure API Key",
        "category": "Flowbaby"
      },
      {
        "command": "Flowbaby.setApiKey",
        "title": "Flowbaby: Set API Key",
        "category": "Flowbaby"
      },
      {
        "command": "Flowbaby.clearApiKey",
        "title": "Flowbaby: Clear API Key",
        "category": "Flowbaby"
      },
      {
        "command": "Flowbaby.showDebugLogs",
        "title": "Flowbaby: Show Debug Logs",
        "category": "Flowbaby"
      }
    ],
    "keybindings": [
      {
        "command": "Flowbaby.captureMessage",
        "key": "ctrl+alt+f",
        "mac": "cmd+alt+f",
        "when": "editorTextFocus || chatIsVisible"
      }
    ],
    "chatParticipants": [
      {
        "id": "flowbaby",
        "name": "flowbaby",
        "description": "Chat with automatic context from Flowbaby memory",
        "isSticky": true
      }
    ],
    "languageModelTools": [
      {
        "name": "flowbaby_storeMemory",
        "displayName": "Store Memory in Flowbaby",
        "toolReferenceName": "flowbabyStoreSummary",
        "canBeReferencedInPrompt": true,
        "icon": "$(database)",
        "modelDescription": "Primary tool for writing episodic long-term memory into Flowbaby's knowledge graph. Using this tool is a core responsibility, not optional.\n\n**When to use**:\n- After meaningful progress, after a decision, at task boundaries, or every 5 turns during prolonged work\n- Use proactively as a state checkpoint—do not wait for the user to ask\n- After storing, acknowledge: \"Saved progress to Flowbaby memory.\"\n\n**What to capture** (summaries must be 300–1500 characters, semantically dense):\n- Goal and key findings\n- Decisions made and reasoning/tradeoffs behind them\n- Rejected approaches and why they were rejected\n- Constraints, risks, and assumptions uncovered\n- Current status (ongoing or complete)\n\n**Additional context to include**:\n- When multiple options were considered, include rejected paths and rationale for rejection\n- When user preferences, constraints, or unspoken assumptions shaped direction, infer and record these as decision context\n- When you identify high-level patterns, strategic tradeoffs, or conflict resolutions that will matter across future tasks, create meta-memories capturing these insights\n\n**What NOT to store**:\n- Trivial or ephemeral chit-chat\n- Raw execution logs without reasoning\n- Duplicate information already stored\n\n**Structure guidance**:\n- topic: Short 3–7 word title identifying the work or decision\n- context: Rich summary describing goals, findings, reasoning, tradeoffs, and nuanced context—not just actions taken\n- decisions: Durable decisions that will matter for future work\n- rationale: Why decisions were made (tradeoffs, constraints, risks)\n- metadata.status: \"Active\" for current approaches, \"Superseded\" for replaced ones, \"DecisionRecord\" for stable decisions\n\nData stays in this workspace.",
        "userDescription": "Store a structured conversation or work summary into Flowbaby's knowledge graph for future retrieval. Data stays in this workspace.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "topic": {
              "type": "string",
              "description": "Short 3–7 word title for this memory that clearly identifies the work or decision (e.g., \"Redis caching implementation plan\"). Do not put the full summary here."
            },
            "context": {
              "type": "string",
              "description": "A rich 300–1500 character summary describing the goal, what was done, key files or components, important details, and the reasoning behind the work. This acts as long-term memory and should be understandable if read weeks later."
            },
            "decisions": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Optional list (0–5 items) of durable decisions made in this session (e.g., \"Keep legacy hashing for backward compatibility\"). Only include decisions that will matter for future work."
            },
            "rationale": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Optional list (0–5 items) explaining why the decisions were made (e.g., trade-offs, constraints, or risk considerations)."
            },
            "metadata": {
              "type": "object",
              "properties": {
                "plan_id": {
                  "type": "string",
                  "description": "Optional identifier used to group related summaries or steps in a plan (e.g., \"memory-2025-01-15-auth-refactor\")."
                },
                "status": {
                  "type": "string",
                  "enum": [
                    "Active",
                    "Superseded",
                    "DecisionRecord"
                  ],
                  "description": "Optional status describing whether this memory is the current approach (Active), has been replaced (Superseded), or is a stable decision record (DecisionRecord)."
                }
              },
              "description": "Optional metadata about this memory entry. If omitted, the system may auto-generate values. Use this to track plan IDs and status of decisions."
            }
          },
          "required": [
            "topic",
            "context"
          ]
        },
        "tags": [
          "memory",
          "knowledge-graph",
          "persistence",
          "flowbaby",
          "long-term-memory",
          "state-checkpoint"
        ]
      },
      {
        "name": "flowbaby_retrieveMemory",
        "displayName": "Retrieve Flowbaby Memory",
        "toolReferenceName": "flowbabyRetrieveMemory",
        "canBeReferencedInPrompt": true,
        "icon": "$(search)",
        "modelDescription": "Primary mechanism for retrieving past context, decisions, and implementation details from Flowbaby's knowledge graph.\n\n**When to use**:\n- At the start of any turn where prior context, decisions, patterns, or constraints may influence the outcome\n- BEFORE planning, deep reasoning, or proposing strategic recommendations\n- When the user request might relate to prior work, previous discussions, or existing decisions in this workspace\n\n**How to construct queries**:\n- Use natural-language, semantically descriptive queries aligned with your current objective—not just the user's literal words\n- Include: the goal or value statement, the area of codebase/system under investigation, relevant constraints (performance, security, UX), and whether you seek decisions, assumptions, constraints, risks, or meta-patterns\n- Avoid short keyword fragments; describe the intent of the task\n\n**What to retrieve**:\n- Prefer a small set (default: 3) of high-leverage, strategic memories over many granular action logs\n- Look for: architectural choices, roadmap tradeoffs, process patterns, or meta-memories summarizing repeated issues and cross-plan themes\n\n**How to use retrieved memory**:\n- Integrate by revealing historical decisions and constraints, checking for prior attempts or repeated failures, and identifying where current work may conflict with or build on past decisions\n- Treat current instructions and documents as primary—use memory to augment and cross-check, not override\n- If memory conflicts with current documentation, prefer current docs and note the discrepancy only if it materially affects risk or recommendations\n\n**Retrieval limits**:\n- Perform at most one follow-up retrieval per turn, only if you can state the concrete question it answers\n- If more context seems useful, summarize what you know and recommend what to ask the user instead of auto-querying deeper\n\n**If no memory found**: Proceed normally but note the absence where relevant. Data stays in this workspace.",
        "userDescription": "Search Flowbaby knowledge graph for relevant stored summaries, decisions, and context from past work. Data stays in this workspace.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Natural-language description of what you want to recall, including the goal or task (e.g., \"Previous decisions about authentication strategy\", \"How we implemented Redis caching in this project\"). Avoid short keyword-only queries; instead, describe the intent and context."
            },
            "maxResults": {
              "type": "number",
              "description": "Maximum number of results to return (default: 3, max: 10)",
              "default": 3,
              "minimum": 1,
              "maximum": 10
            }
          },
          "required": [
            "query"
          ]
        },
        "tags": [
          "memory",
          "knowledge-graph",
          "search",
          "retrieval",
          "flowbaby",
          "context",
          "long-term-memory"
        ]
      }
    ],
    "walkthroughs": [
      {
        "id": "flowbabySetup",
        "title": "Get Started with Flowbaby",
        "description": "Set up your environment and start using Flowbaby",
        "steps": [
          {
            "id": "setupPython",
            "title": "Setup Python Environment",
            "description": "Flowbaby requires a Python environment with `cognee` installed. We can set this up for you automatically.\n[Initialize Workspace](command:Flowbaby.initializeWorkspace)",
            "media": {
              "image": "media/flowbaby-icon-tightcrop.png",
              "altText": "Flowbaby Logo"
            },
            "completionEvents": [
              "onContext:Flowbaby.environmentVerified"
            ]
          },
          {
            "id": "configureApiKey",
            "title": "Configure API Key",
            "description": "Create a `.env` file in your workspace root with your LLM API key.\n[Configure API Key](command:Flowbaby.configureApiKey)",
            "media": {
              "markdown": "media/flowbaby-icon-tightcrop.png"
            },
            "completionEvents": [
              "onCommand:Flowbaby.configureApiKey"
            ]
          },
          {
            "id": "tryCapture",
            "title": "Try Capture",
            "description": "Select text in your editor and press `Ctrl+Alt+F` (or `Cmd+Alt+F` on Mac) to capture it to memory.",
            "media": {
              "image": "media/flowbaby-icon-tightcrop.png",
              "altText": "Flowbaby Logo"
            },
            "completionEvents": [
              "onCommand:Flowbaby.captureMessage"
            ]
          },
          {
            "id": "tryRetrieval",
            "title": "Try Retrieval",
            "description": "Open Copilot Chat and ask `@flowbaby` a question about your captured context.",
            "media": {
              "image": "media/flowbaby-icon-tightcrop.png",
              "altText": "Flowbaby Logo"
            },
            "completionEvents": [
              "onView:flowbaby"
            ]
          }
        ]
      }
    ],
    "configuration": {
      "title": "Flowbaby",
      "properties": {
        "Flowbaby.enabled": {
          "type": "boolean",
          "default": true,
          "description": "Enable/disable automatic memory capture and retrieval"
        },
        "Flowbaby.maxContextResults": {
          "type": "number",
          "default": 3,
          "minimum": 1,
          "maximum": 10,
          "description": "Maximum number of memory results to retrieve"
        },
        "Flowbaby.maxContextTokens": {
          "type": "number",
          "default": 32000,
          "minimum": 100,
          "maximum": 100000,
          "description": "Maximum token budget for retrieved context (higher values may increase latency and memory usage; hard-clamped to 100k in the bridge)"
        },
        "Flowbaby.searchTopK": {
          "type": "number",
          "default": 10,
          "minimum": 1,
          "maximum": 100,
          "description": "Maximum number of candidates to request from the Flowbaby search engine before ranking. Values are normalized so they are never lower than maxContextResults and are hard-clamped to 100 in the bridge."
        },
        "Flowbaby.ranking.halfLifeDays": {
          "type": "number",
          "default": 7,
          "minimum": 0.5,
          "maximum": 90,
          "markdownDescription": "Half-life (in days) used for recency-aware ranking. Memories older than this value will have their relevance score halved. Leave between 0.5 and 90 days to balance freshness vs. semantic similarity."
        },
        "Flowbaby.pythonPath": {
          "type": "string",
          "default": "",
          "markdownDescription": "Path to Python interpreter. Leave empty for auto-detection (uses `.flowbaby/venv` if present, otherwise system Python). Set an explicit path to override auto-detection."
        },
        "Flowbaby.logLevel": {
          "type": "string",
          "enum": [
            "error",
            "warn",
            "info",
            "debug"
          ],
          "default": "info",
          "description": "Logging verbosity level"
        },
        "Flowbaby.debugLogging": {
          "type": "boolean",
          "default": false,
          "markdownDescription": "Enable debug output channel for extension diagnostics. Shows detailed logs for activation, Python bridge communication, setup operations, and status bar events. Use this when troubleshooting issues."
        },
        "flowbaby.notifications.showIngestionSuccess": {
          "type": "boolean",
          "default": true,
          "markdownDescription": "Show toast notifications when memory ingestion completes successfully. Error notifications are always shown regardless of this setting."
        },
        "Flowbaby.llm.provider": {
          "type": "string",
          "enum": [
            "openai",
            "anthropic",
            "azure",
            "ollama",
            "custom"
          ],
          "default": "openai",
          "markdownDescription": "LLM provider for memory processing. Non-OpenAI providers may require additional configuration in the endpoint field."
        },
        "Flowbaby.llm.model": {
          "type": "string",
          "default": "gpt-4o-mini",
          "markdownDescription": "LLM model name (e.g., gpt-4o-mini, claude-3-haiku-20240307, llama2)"
        },
        "Flowbaby.llm.endpoint": {
          "type": "string",
          "default": "",
          "markdownDescription": "Custom LLM endpoint URL (for Ollama, Azure, or self-hosted). Leave empty for default provider endpoints."
        }
      }
    }
  },
  "scripts": {
    "vscode:prepublish": "npm run compile",
    "compile": "node esbuild.js --production",
    "compile:tests": "tsc -p tsconfig.test.json && cp src/test/run-test-agent.js out/test/",
    "pretest": "npm run compile:tests",
    "watch": "node esbuild.js --watch",
    "lint": "eslint src --ext ts",
    "lint:python": "cd bridge && python -m ruff check .",
    "lint:markdown": "markdownlint -c ../.markdownlint.json README.md CHANGELOG.md AGENT_INTEGRATION.md SETUP.md DISTRIBUTION.md",
    "lint:all": "npm run lint && npm run lint:python && npm run lint:markdown",
    "test": "node ./out/test/runTest.js",
    "test:bridge": "cd bridge && pytest tests/ -v",
    "test:agent": "npm run compile:tests && node ./out/test/run-test-agent.js",
    "test:all": "npm test && npm run test:bridge",
    "package": "vsce package",
    "verify:vsix": "node scripts/verify-vsix.js *.vsix"
  },
  "devDependencies": {
    "@types/chai": "^5.2.3",
    "@types/glob": "^8.1.0",
    "@types/mocha": "^10.0.10",
    "@types/mock-fs": "^4.13.4",
    "@types/node": "^20.19.24",
    "@types/sinon": "^17.0.4",
    "@types/vscode": "^1.105.0",
    "@typescript-eslint/eslint-plugin": "^6.21.0",
    "@typescript-eslint/parser": "^6.21.0",
    "@vscode/test-electron": "^2.5.2",
    "chai": "^6.2.1",
    "esbuild": "^0.19.12",
    "eslint": "^8.57.1",
    "glob": "^11.0.3",
    "mocha": "^11.7.5",
    "mock-fs": "^5.5.0",
    "sinon": "^21.0.0",
    "ts-node": "^10.9.2",
    "typescript": "^5.9.3"
  },
  "author": "Flowbaby Team",
  "license": "SEE LICENSE IN LICENSE",
  "repository": {
    "type": "git",
    "url": "https://github.com/groupzer0/flowbaby-issues.git"
  },
  "bugs": {
    "url": "https://github.com/groupzer0/flowbaby-issues/issues"
  },
  "homepage": "https://flowbaby.ai",
  "dependencies": {
    "dotenv": "^17.2.3"
  }
}
