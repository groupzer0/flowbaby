{
  "name": "flowbaby",
  "displayName": "Flowbaby",
  "description": "The only memory system that isn't wearing a memory costume. No drift. No drama",
  "version": "0.7.0",
  "publisher": "Flowbaby",
  "icon": "media/flowbaby-icon-tightcrop.png",
  "engines": {
    "vscode": "^1.106.0"
  },
  "categories": [
    "AI",
    "Chat",
    "Other"
  ],
  "screenshots": [
    {
      "path": "media/auto-search.png",
      "caption": "Automatic context search"
    },
    {
      "path": "media/auto-store.png",
      "caption": "Automatic memory storage"
    },
    {
      "path": "media/interactive-chat-participant.png",
      "caption": "Interactive @flowbaby chat participant"
    },
    {
      "path": "media/manual-store-summary.png",
      "caption": "Manual memory capture via command palette"
    }
  ],
  "keywords": [
    "flowbaby",
    "copilot",
    "github copilot",
    "chat",
    "memory",
    "workspace memory",
    "knowledge graph",
    "llm",
    "context",
    "retrieval",
    "rags",
    "agent",
    "vs code",
    "developer productivity"
  ],
  "activationEvents": [
    "onStartupFinished",
    "onLanguageModelTool:flowbaby_storeMemory"
  ],
  "main": "./dist/extension.js",
  "contributes": {
    "commands": [
      {
        "command": "Flowbaby.captureMessage",
        "title": "Flowbaby: Capture to Memory",
        "category": "Flowbaby"
      },
      {
        "command": "Flowbaby.toggleMemory",
        "title": "Flowbaby: Toggle Memory",
        "category": "Flowbaby"
      },
      {
        "command": "Flowbaby.clearMemory",
        "title": "Flowbaby: Clear Workspace Memory",
        "category": "Flowbaby"
      },
      {
        "command": "Flowbaby.ingestForAgent",
        "title": "Flowbaby: Ingest Summary for Agent",
        "category": "Flowbaby",
        "enablement": "Flowbaby.enabled"
      },
      {
        "command": "Flowbaby.retrieveForAgent",
        "title": "Flowbaby: Retrieve Context for Agent",
        "category": "Flowbaby",
        "enablement": "Flowbaby.enabled"
      },
      {
        "command": "Flowbaby.backgroundStatus",
        "title": "Flowbaby: View Background Operations",
        "category": "Flowbaby"
      },
      {
        "command": "Flowbaby.showStatus",
        "title": "Flowbaby: Show Status",
        "category": "Flowbaby"
      },
      {
        "command": "Flowbaby.openDocs",
        "title": "Flowbaby: Open Documentation",
        "category": "Flowbaby"
      },
      {
        "command": "Flowbaby.validateMemories",
        "title": "Flowbaby: Validate Memories",
        "category": "Flowbaby"
      },
      {
        "command": "Flowbaby.listMemories",
        "title": "Flowbaby: List Memories",
        "category": "Flowbaby"
      },
      {
        "command": "Flowbaby.refreshDependencies",
        "title": "Flowbaby: Refresh Bridge Dependencies",
        "category": "Flowbaby"
      },
      {
        "command": "Flowbaby.initializeWorkspace",
        "title": "Flowbaby: Initialize Workspace",
        "category": "Flowbaby"
      },
      {
        "command": "Flowbaby.setupEnvironment",
        "title": "Flowbaby: Setup Environment (Legacy)",
        "category": "Flowbaby"
      },
      {
        "command": "Flowbaby.showDebugLogs",
        "title": "Flowbaby: Show Debug Logs",
        "category": "Flowbaby"
      },
      {
        "command": "Flowbaby.visualizeGraph",
        "title": "Flowbaby: Visualize Memory Graph",
        "category": "Flowbaby"
      },
      {
        "command": "flowbaby.cloud.login",
        "title": "Flowbaby Cloud: Login with GitHub",
        "category": "Flowbaby Cloud"
      },
      {
        "command": "flowbaby.cloud.logout",
        "title": "Flowbaby Cloud: Logout",
        "category": "Flowbaby Cloud"
      },
      {
        "command": "flowbaby.cloud.status",
        "title": "Flowbaby Cloud: Show Status",
        "category": "Flowbaby Cloud"
      }
    ],
    "keybindings": [
      {
        "command": "Flowbaby.captureMessage",
        "key": "ctrl+alt+f",
        "mac": "cmd+alt+f"
      }
    ],
    "chatParticipants": [
      {
        "id": "flowbaby",
        "name": "flowbaby",
        "description": "Chat with automatic context from Flowbaby memory",
        "isSticky": true
      }
    ],
    "languageModelTools": [
      {
        "name": "flowbaby_storeMemory",
        "displayName": "Store Memory in Flowbaby",
        "toolReferenceName": "flowbabyStoreSummary",
        "canBeReferencedInPrompt": true,
        "icon": "$(database)",
        "modelDescription": "Primary tool for writing episodic long-term memory into Flowbaby's knowledge graph. Using this tool is a core responsibility, not optional.\n\n**When to use**:\n- After meaningful progress, after a decision, at task boundaries, or every 5 turns during prolonged work\n- Use proactively as a state checkpoint—do not wait for the user to ask\n- After storing, acknowledge: \"Saved progress to Flowbaby memory.\"\n\n**What to capture** (summaries must be 300–1500 characters, semantically dense):\n- Goal and key findings\n- Decisions made and reasoning/tradeoffs behind them\n- Rejected approaches and why they were rejected\n- Constraints, risks, and assumptions uncovered\n- Current status (ongoing or complete)\n\n**Additional context to include**:\n- When multiple options were considered, include rejected paths and rationale for rejection\n- When user preferences, constraints, or unspoken assumptions shaped direction, infer and record these as decision context\n- When you identify high-level patterns, strategic tradeoffs, or conflict resolutions that will matter across future tasks, create meta-memories capturing these insights\n\n**What NOT to store**:\n- Trivial or ephemeral chit-chat\n- Raw execution logs without reasoning\n- Duplicate information already stored\n\n**Structure guidance**:\n- topic: Short 3–7 word title identifying the work or decision\n- context: Rich summary describing goals, findings, reasoning, tradeoffs, and nuanced context—not just actions taken\n- decisions: Durable decisions that will matter for future work\n- rationale: Why decisions were made (tradeoffs, constraints, risks)\n- metadata.status: \"Active\" for current approaches, \"Superseded\" for replaced ones, \"DecisionRecord\" for stable decisions\n\nData stays in this workspace.",
        "userDescription": "Store a structured conversation or work summary into Flowbaby's knowledge graph for future retrieval. Data stays in this workspace.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "topic": {
              "type": "string",
              "description": "Short 3–7 word title for this memory that clearly identifies the work or decision (e.g., \"Redis caching implementation plan\"). Do not put the full summary here."
            },
            "context": {
              "type": "string",
              "description": "A rich 300–1500 character summary describing the goal, what was done, key files or components, important details, and the reasoning behind the work. This acts as long-term memory and should be understandable if read weeks later."
            },
            "decisions": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Optional list (0–5 items) of durable decisions made in this session (e.g., \"Keep legacy hashing for backward compatibility\"). Only include decisions that will matter for future work."
            },
            "rationale": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Optional list (0–5 items) explaining why the decisions were made (e.g., trade-offs, constraints, or risk considerations)."
            },
            "metadata": {
              "type": "object",
              "properties": {
                "plan_id": {
                  "type": "string",
                  "description": "Optional identifier used to group related summaries or steps in a plan (e.g., \"memory-2025-01-15-auth-refactor\")."
                },
                "status": {
                  "type": "string",
                  "enum": [
                    "Active",
                    "Superseded",
                    "DecisionRecord"
                  ],
                  "description": "Optional status describing whether this memory is the current approach (Active), has been replaced (Superseded), or is a stable decision record (DecisionRecord)."
                }
              },
              "description": "Optional metadata about this memory entry. If omitted, the system may auto-generate values. Use this to track plan IDs and status of decisions."
            }
          },
          "required": [
            "topic",
            "context"
          ]
        },
        "tags": [
          "memory",
          "knowledge-graph",
          "persistence",
          "flowbaby",
          "long-term-memory",
          "state-checkpoint"
        ]
      },
      {
        "name": "flowbaby_retrieveMemory",
        "displayName": "Retrieve Flowbaby Memory",
        "toolReferenceName": "flowbabyRetrieveMemory",
        "canBeReferencedInPrompt": true,
        "icon": "$(search)",
        "modelDescription": "Primary mechanism for retrieving past context, decisions, and implementation details from Flowbaby's knowledge graph.\n\n**When to use**:\n- At the start of any turn where prior context, decisions, patterns, or constraints may influence the outcome\n- BEFORE planning, deep reasoning, or proposing strategic recommendations\n- When the user request might relate to prior work, previous discussions, or existing decisions in this workspace\n\n**How to construct queries**:\n- Use natural-language, semantically descriptive queries aligned with your current objective—not just the user's literal words\n- Include: the goal or value statement, the area of codebase/system under investigation, relevant constraints (performance, security, UX), and whether you seek decisions, assumptions, constraints, risks, or meta-patterns\n- Avoid short keyword fragments; describe the intent of the task\n\n**What to retrieve**:\n- Prefer a small set (default: 3) of high-leverage, strategic memories over many granular action logs\n- Look for: architectural choices, roadmap tradeoffs, process patterns, or meta-memories summarizing repeated issues and cross-plan themes\n\n**How to use retrieved memory**:\n- Integrate by revealing historical decisions and constraints, checking for prior attempts or repeated failures, and identifying where current work may conflict with or build on past decisions\n- Treat current instructions and documents as primary—use memory to augment and cross-check, not override\n- If memory conflicts with current documentation, prefer current docs and note the discrepancy only if it materially affects risk or recommendations\n\n**Retrieval limits**:\n- Perform at most one follow-up retrieval per turn, only if you can state the concrete question it answers\n- If more context seems useful, summarize what you know and recommend what to ask the user instead of auto-querying deeper\n\n**If no memory found**: Proceed normally but note the absence where relevant. Data stays in this workspace.",
        "userDescription": "Search Flowbaby knowledge graph for relevant stored summaries, decisions, and context from past work. Data stays in this workspace.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Natural-language description of what you want to recall, including the goal or task (e.g., \"Previous decisions about authentication strategy\", \"How we implemented Redis caching in this project\"). Avoid short keyword-only queries; instead, describe the intent and context."
            },
            "maxResults": {
              "type": "number",
              "description": "Maximum number of results to return (default: 3, max: 10)",
              "default": 3,
              "minimum": 1,
              "maximum": 10
            }
          },
          "required": [
            "query"
          ]
        },
        "tags": [
          "memory",
          "knowledge-graph",
          "search",
          "retrieval",
          "flowbaby",
          "context",
          "long-term-memory"
        ]
      }
    ],
    "walkthroughs": [
      {
        "id": "flowbabySetup",
        "title": "Get Started with Flowbaby",
        "description": "Set up your environment and start using Flowbaby",
        "steps": [
          {
            "id": "setupPython",
            "title": "Setup Python Environment",
            "description": "Flowbaby requires a Python environment with `cognee` installed. We can set this up for you automatically.\n[Initialize Workspace](command:Flowbaby.initializeWorkspace)",
            "media": {
              "image": "media/flowbaby-icon-tightcrop.png",
              "altText": "Flowbaby Logo"
            },
            "completionEvents": [
              "onContext:Flowbaby.environmentVerified"
            ]
          },
          {
            "id": "loginCloud",
            "title": "Login to Flowbaby Cloud",
            "description": "Login to Flowbaby Cloud to enable LLM-powered memory operations. Authentication uses GitHub OAuth.\n\n☁️ **No API key required** — Flowbaby Cloud provides managed LLM access via AWS Bedrock.\n\n[Login to Cloud](command:FlowbabyCloud.login)",
            "media": {
              "image": "media/flowbaby-icon-tightcrop.png",
              "altText": "Cloud Login"
            },
            "completionEvents": [
              "onCommand:FlowbabyCloud.login"
            ]
          },
          {
            "id": "copilotInstructions",
            "title": "Add Memory Instructions (Recommended)",
            "description": "For best results, add memory instructions to your workspace. This encourages Copilot to proactively store and retrieve memories.\n\n[View Memory Contract Example](https://github.com/groupzer0/vs-code-agents/blob/main/vs-code-agents/reference/memory-contract-example.md)",
            "media": {
              "image": "media/flowbaby-icon-tightcrop.png",
              "altText": "Memory Instructions"
            }
          },
          {
            "id": "tryCapture",
            "title": "Try Capture",
            "description": "Select text in your editor and press `Ctrl+Alt+F` (or `Cmd+Alt+F` on Mac) to capture it to memory.",
            "media": {
              "image": "media/flowbaby-icon-tightcrop.png",
              "altText": "Flowbaby Logo"
            },
            "completionEvents": [
              "onCommand:Flowbaby.captureMessage"
            ]
          },
          {
            "id": "tryRetrieval",
            "title": "Try Retrieval",
            "description": "Open Copilot Chat and ask `@flowbaby` a question about your captured context.",
            "media": {
              "image": "media/flowbaby-icon-tightcrop.png",
              "altText": "Flowbaby Logo"
            },
            "completionEvents": [
              "onView:flowbaby"
            ]
          }
        ]
      }
    ],
    "configuration": {
      "title": "Flowbaby",
      "properties": {
        "Flowbaby.enabled": {
          "type": "boolean",
          "default": true,
          "description": "Enable/disable automatic memory capture and retrieval"
        },
        "Flowbaby.maxContextResults": {
          "type": "number",
          "default": 3,
          "minimum": 1,
          "maximum": 10,
          "description": "Maximum number of memory results to retrieve"
        },
        "Flowbaby.maxContextTokens": {
          "type": "number",
          "default": 32000,
          "minimum": 100,
          "maximum": 100000,
          "description": "Maximum token budget for retrieved context (higher values may increase latency and memory usage; hard-clamped to 100k in the bridge)"
        },
        "Flowbaby.searchTopK": {
          "type": "number",
          "default": 10,
          "minimum": 1,
          "maximum": 100,
          "description": "Maximum number of candidates to request from the Flowbaby search engine before ranking. Values are normalized so they are never lower than maxContextResults and are hard-clamped to 100 in the bridge."
        },
        "Flowbaby.ranking.halfLifeDays": {
          "type": "number",
          "default": 7,
          "minimum": 0.5,
          "maximum": 90,
          "markdownDescription": "Half-life (in days) used for recency-aware ranking. Memories older than this value will have their relevance score halved. Leave between 0.5 and 90 days to balance freshness vs. semantic similarity."
        },
        "Flowbaby.advancedSearch.wideSearchTopK": {
          "type": "number",
          "default": 150,
          "minimum": 10,
          "maximum": 500,
          "markdownDescription": "(Advanced) Maximum number of graph triplets to retrieve during wide graph search. Higher values may improve recall but increase latency. Plan 063: Widen graph search for richer context."
        },
        "Flowbaby.advancedSearch.tripletDistancePenalty": {
          "type": "number",
          "default": 3,
          "minimum": 0.1,
          "maximum": 10,
          "markdownDescription": "(Advanced) Penalty applied to triplet distance during graph search ranking. Lower values favor closer triplets; higher values relax distance requirements. Plan 063: Tune for better recall."
        },
        "Flowbaby.pythonPath": {
          "type": "string",
          "default": "",
          "markdownDescription": "Path to Python interpreter. Leave empty for auto-detection (uses `.flowbaby/venv` if present, otherwise system Python). Set an explicit path to override auto-detection."
        },
        "Flowbaby.logLevel": {
          "type": "string",
          "enum": [
            "error",
            "warn",
            "info",
            "debug"
          ],
          "default": "info",
          "description": "Logging verbosity level"
        },
        "Flowbaby.debugLogging": {
          "type": "boolean",
          "default": false,
          "markdownDescription": "Enable debug output channel for extension diagnostics. Shows detailed logs for activation, Python bridge communication, setup operations, and status bar events. Use this when troubleshooting issues."
        },
        "Flowbaby.bridgeMode": {
          "type": "string",
          "enum": [
            "daemon",
            "spawn"
          ],
          "default": "daemon",
          "markdownDescription": "Bridge execution mode. **daemon** (default) uses a long-lived Python process for faster requests (~300ms vs ~2-3s). **spawn** uses the legacy per-request process spawn. Use spawn for troubleshooting if daemon mode causes issues."
        },
        "Flowbaby.daemonIdleTimeoutMinutes": {
          "type": "number",
          "default": 30,
          "minimum": 1,
          "maximum": 60,
          "markdownDescription": "Minutes of inactivity before the bridge daemon exits. Next request will restart it with a small warm-up delay. Lower values save memory; higher values keep the daemon ready. (Plan 061: default increased from 5 to 30 minutes)"
        },
        "Flowbaby.sessionManagement.enabled": {
          "type": "boolean",
          "default": true,
          "markdownDescription": "Control whether Flowbaby groups interactions into sessions. When enabled, Flowbaby attaches a session ID to retrieval and ingestion so related chats stay together. Disable to make interactions stateless."
        },
        "flowbaby.notifications.showIngestionSuccess": {
          "type": "boolean",
          "default": true,
          "markdownDescription": "Show toast notifications when memory ingestion completes successfully. Error notifications are always shown regardless of this setting."
        },
        "flowbaby.showRetrievalNotifications": {
          "type": "boolean",
          "default": true,
          "markdownDescription": "Show a notification when Flowbaby retrieves relevant memories. Disable to suppress retrieval toasts. Plan 067."
        },
        "Flowbaby.synthesis.modelId": {
          "type": "string",
          "enum": [
            "gpt-5-mini",
            "gpt-4o",
            "gpt-4.1"
          ],
          "enumDescriptions": [
            "GPT-5 mini - Fast, capable, and cost-effective (recommended)",
            "GPT-4o - High capability, balanced performance",
            "GPT-4.1 - Latest GPT-4 series model"
          ],
          "default": "gpt-5-mini",
          "markdownDescription": "**Copilot synthesis model** used for Plan 073 memory retrieval. This setting controls which VS Code LM API (Copilot) model synthesizes answers from retrieved graph context.\n\nSynthesis fails with a clear error if the selected model is unavailable (no silent fallback).\n\n**Note**: This curated list is reviewed each release as Copilot model availability evolves."
        },
        "flowbaby.cloud.preferredZone": {
          "type": "string",
          "enum": [
            "",
            "us",
            "eu",
            "apac"
          ],
          "enumDescriptions": [
            "Backend default (recommended)",
            "United States",
            "Europe",
            "Asia Pacific"
          ],
          "default": "",
          "markdownDescription": "**Flowbaby Cloud: Preferred geographic zone** for Bedrock LLM calls.\n\nLeave empty to use the backend default (recommended). The backend validates your preference and returns the authoritative zone and region.\n\n**Note**: This setting replaces `preferredRegion`. Values: `us`, `eu`, `apac`."
        },
        "flowbaby.cloud.apiEndpoint": {
          "type": "string",
          "default": "",
          "markdownDescription": "**Flowbaby Cloud: API endpoint override** (developer/testing only). Leave empty for the built-in default (`api-staging.flowbaby.ai` for staging, `api.flowbaby.ai` for production). Set an explicit URL to override endpoint resolution."
        }
      }
    }
  },
  "scripts": {
    "vscode:prepublish": "npm run compile",
    "compile": "node esbuild.js --production",
    "compile:tests": "tsc -p tsconfig.test.json && node -e \"const fs=require('fs'); const path=require('path'); const src=path.join('src','test','run-test-agent.js'); const dstDir=path.join('out','test'); const dst=path.join(dstDir,'run-test-agent.js'); fs.mkdirSync(dstDir,{recursive:true}); fs.copyFileSync(src,dst);\"",
    "pretest": "npm run compile:tests",
    "watch": "node esbuild.js --watch",
    "lint": "eslint src --ext ts",
    "lint:python": "node -e \"const cp=require('child_process'); const fs=require('fs'); const path=require('path'); const extensionDir=__dirname; const bridgeDir=path.join(extensionDir,'bridge'); const rootDir=path.resolve(extensionDir,'..'); const candidates=process.platform==='win32' ? [path.join(rootDir,'.flowbaby','venv','Scripts','python.exe'),'python','py'] : [path.join(rootDir,'.flowbaby','venv','bin','python'),'python3','python']; const canUse=(cmd)=>!cmd.includes(path.sep)||fs.existsSync(cmd); const probe=(cmd)=>{ const r=cp.spawnSync(cmd,['-m','ruff','--version'],{cwd:bridgeDir,stdio:'ignore'}); return r.status===0; }; const run=(cmd)=>{ const r=cp.spawnSync(cmd,['-m','ruff','check','.'],{cwd:bridgeDir,stdio:'inherit'}); process.exit(typeof r.status==='number'?r.status:1); }; for (const cmd of candidates){ if (!canUse(cmd)) continue; if (probe(cmd)) run(cmd); } console.error('ruff is not available. Install it (e.g. pip install ruff) or initialize Flowbaby to create .flowbaby/venv.'); process.exit(1);\"",
    "lint:markdown": "markdownlint -c .markdownlint.json README.md CHANGELOG.md AGENT_INTEGRATION.md SETUP.md DISTRIBUTION.md",
    "lint:all": "npm run lint && npm run lint:python && npm run lint:markdown",
    "check:zones": "node scripts/check-zone-allowlist.js",
    "test": "node ./out/test/runTest.js",
    "test:bridge": "cd bridge && pytest tests/ -v",
    "test:agent": "npm run compile:tests && node ./out/test/run-test-agent.js",
    "test:all": "npm test && npm run test:bridge && npm run check:zones",
    "package": "vsce package",
    "verify:vsix": "node scripts/verify-vsix.js *.vsix"
  },
  "devDependencies": {
    "@types/chai": "^5.2.3",
    "@types/glob": "^8.1.0",
    "@types/mocha": "^10.0.10",
    "@types/mock-fs": "^4.13.4",
    "@types/node": "^20.19.24",
    "@types/sinon": "^17.0.4",
    "@types/vscode": "^1.105.0",
    "@typescript-eslint/eslint-plugin": "^6.21.0",
    "@typescript-eslint/parser": "^6.21.0",
    "@vscode/test-electron": "^2.5.2",
    "chai": "^6.2.1",
    "esbuild": "^0.19.12",
    "eslint": "^8.57.1",
    "glob": "^11.0.3",
    "markdownlint-cli": "^0.44.0",
    "mocha": "^11.7.5",
    "mock-fs": "^5.5.0",
    "sinon": "^21.0.0",
    "ts-node": "^10.9.2",
    "typescript": "^5.9.3"
  },
  "author": "Flowbaby Team",
  "license": "SEE LICENSE IN LICENSE",
  "repository": {
    "type": "git",
    "url": "https://github.com/groupzer0/flowbaby.git"
  },
  "bugs": {
    "url": "https://github.com/groupzer0/flowbaby/issues"
  },
  "homepage": "https://flowbaby.ai",
  "dependencies": {
    "@groupzer0/flowbaby-api-contract": "^3.4.0",
    "@types/uuid": "^10.0.0",
    "dotenv": "^17.2.3",
    "uuid": "^13.0.0"
  }
}
