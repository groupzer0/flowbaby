{
  "name": "cognee-chat-memory",
  "displayName": "RecallFlow Chat Memory",
  "description": "Automatic memory for GitHub Copilot chat using RecallFlow (formerly Cognee) knowledge graphs",
  "version": "0.3.7",
  "publisher": "recallflow",
  "icon": "media/icon.png",
  "engines": {
    "vscode": "^1.106.0"
  },
  "categories": [
    "AI",
    "Chat",
    "Machine Learning"
  ],
  "keywords": [
    "recallflow",
    "cognee",
    "memory",
    "chat",
    "copilot",
    "knowledge-graph",
    "context",
    "ai",
    "llm",
    "context-retrieval"
  ],
  "activationEvents": [
    "onStartupFinished",
    "onLanguageModelTool:recallflow_storeMemory"
  ],
  "main": "./dist/extension.js",
  "contributes": {
    "commands": [
      {
        "command": "cognee.captureMessage",
        "title": "ðŸ“¥ Capture to RecallFlow Memory",
        "category": "RecallFlow"
      },
      {
        "command": "cognee.toggleMemory",
        "title": "Toggle RecallFlow Memory",
        "category": "RecallFlow"
      },
      {
        "command": "cognee.clearMemory",
        "title": "Clear RecallFlow Workspace Memory",
        "category": "RecallFlow"
      },
      {
        "command": "cogneeMemory.ingestForAgent",
        "title": "Ingest Summary for RecallFlow Agent",
        "category": "RecallFlow",
        "enablement": "cogneeMemory.enabled"
      },
      {
        "command": "cogneeMemory.retrieveForAgent",
        "title": "Retrieve Context for RecallFlow Agent",
        "category": "RecallFlow",
        "enablement": "cogneeMemory.enabled"
      },
      {
        "command": "cognee.backgroundStatus",
        "title": "View Background Operations",
        "category": "RecallFlow"
      }
    ],

    "keybindings": [
      {
        "command": "cognee.captureMessage",
        "key": "ctrl+alt+c",
        "mac": "cmd+alt+c",
        "when": "editorTextFocus || chatIsVisible"
      }
    ],
    "chatParticipants": [
      {
        "id": "recallflow-memory",
        "name": "recallflow-memory",
        "description": "Chat with automatic context from RecallFlow memory",
        "isSticky": true
      }
    ],
    "languageModelTools": [
      {
        "name": "recallflow_storeMemory",
        "displayName": "Store Memory in RecallFlow",
        "toolReferenceName": "recallflowStoreSummary",
        "canBeReferencedInPrompt": true,
        "icon": "$(database)",
        "modelDescription": "Primary tool for writing episodic long-term memory into RecallFlow's knowledge graph. Agents should call this after meaningful progress, at the end of multi-step reasoning, or when concluding a task, to persist a rich summary of what was done and why. Use this tool proactively as a state checkpoint; do not wait for the user to explicitly ask to save memory. Summaries should be 300â€“1500 characters and describe goals, actions, important files, decisions, and rationale. Use it to record durable decisions, plans, and implementation notes that will be useful in future turns in this workspace. Do not use this for trivial or ephemeral chit-chat.\n\nExample usage (conceptual): after completing a refactor or design decision, call this tool with topic=\"Auth refactor step 1\" and context summarizing the work, and include any key decisions and rationale. Data stays in this workspace.",
        "userDescription": "Store a structured conversation or work summary into RecallFlow's knowledge graph for future retrieval. Data stays in this workspace.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "topic": {
              "type": "string",
              "description": "Short 3â€“7 word title for this memory that clearly identifies the work or decision (e.g., \"Redis caching implementation plan\"). Do not put the full summary here."
            },
            "context": {
              "type": "string",
              "description": "A rich 300â€“1500 character summary describing the goal, what was done, key files or components, important details, and the reasoning behind the work. This acts as long-term memory and should be understandable if read weeks later."
            },
            "decisions": {
              "type": "array",
              "items": {"type": "string"},
              "description": "Optional list (0â€“5 items) of durable decisions made in this session (e.g., \"Keep legacy hashing for backward compatibility\"). Only include decisions that will matter for future work."
            },
            "rationale": {
              "type": "array",
              "items": {"type": "string"},
              "description": "Optional list (0â€“5 items) explaining why the decisions were made (e.g., trade-offs, constraints, or risk considerations)."
            },
            "metadata": {
              "type": "object",
              "properties": {
                "plan_id": {
                  "type": "string",
                  "description": "Optional identifier used to group related summaries or steps in a plan (e.g., \"memory-2025-01-15-auth-refactor\")."
                },
                "status": {
                  "type": "string",
                  "enum": ["Active", "Superseded", "DecisionRecord"],
                  "description": "Optional status describing whether this memory is the current approach (Active), has been replaced (Superseded), or is a stable decision record (DecisionRecord)."
                }
              },
              "description": "Optional metadata about this memory entry. If omitted, the system may auto-generate values. Use this to track plan IDs and status of decisions."
            }
          },
          "required": ["topic", "context"]
        },
        "tags": ["memory", "knowledge-graph", "persistence", "recallflow", "long-term-memory", "state-checkpoint"]
      },
      {
        "name": "recallflow_retrieveMemory",
        "displayName": "Retrieve RecallFlow Memory",
        "toolReferenceName": "recallflowRetrieveMemory",
        "canBeReferencedInPrompt": true,
        "icon": "$(search)",
        "modelDescription": "Primary mechanism for retrieving past context, decisions, and implementation details from RecallFlow's knowledge graph. Agents should call this at the start of a turn, or before planning an answer, whenever the user request might relate to prior work, previous discussions, or existing decisions in this workspace. Use a natural-language query that describes the user goal or task (not just keywords), and retrieve a small number of highly relevant memories to ground reasoning. The tool returns human-readable markdown plus structured JSON with topic, context, decisions, rationale, and metadata, which should be used to guide current planning and responses. If no results are relevant, the agent should proceed but note that no prior memory was found.\n\nExample usage (conceptual): when asked \"How did we implement caching?\" call this tool with query=\"Previous decisions and implementation details for redis caching\" and review the returned summaries before answering. Data stays in this workspace.",
        "userDescription": "Search RecallFlow knowledge graph for relevant stored summaries, decisions, and context from past work. Data stays in this workspace.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Natural-language description of what you want to recall, including the goal or task (e.g., \"Previous decisions about authentication strategy\", \"How we implemented Redis caching in this project\"). Avoid short keyword-only queries; instead, describe the intent and context."
            },
            "maxResults": {
              "type": "number",
              "description": "Maximum number of results to return (default: 3, max: 10)",
              "default": 3,
              "minimum": 1,
              "maximum": 10
            }
          },
          "required": ["query"]
        },
        "tags": ["memory", "knowledge-graph", "search", "retrieval", "recallflow", "context", "long-term-memory"]
      }
    ],
    "configuration": {
      "title": "RecallFlow Memory",
      "properties": {
        "cogneeMemory.enabled": {
          "type": "boolean",
          "default": true,
          "description": "Enable/disable automatic memory capture and retrieval"
        },
        "cogneeMemory.maxContextResults": {
          "type": "number",
          "default": 3,
          "minimum": 1,
          "maximum": 10,
          "description": "Maximum number of memory results to retrieve"
        },
        "cogneeMemory.maxContextTokens": {
          "type": "number",
          "default": 2000,
          "minimum": 100,
          "maximum": 10000,
          "description": "Maximum token budget for retrieved context"
        },
        "cogneeMemory.ranking.halfLifeDays": {
          "type": "number",
          "default": 7,
          "minimum": 0.5,
          "maximum": 90,
          "markdownDescription": "Half-life (in days) used for recency-aware ranking. Memories older than this value will have their relevance score halved. Leave between 0.5 and 90 days to balance freshness vs. semantic similarity."
        },
        "cogneeMemory.autoIngestConversations": {
          "type": "boolean",
          "default": false,
          "markdownDescription": "**Experimental**: Automatically capture @cognee-memory conversations for feedback loop. Currently disabled by default due to Cognee 0.4.0 file storage issues. Enable to test self-improving memory (may fail intermittently)."
        },
        "cogneeMemory.pythonPath": {
          "type": "string",
          "default": "python3",
          "markdownDescription": "Path to Python interpreter. Leave as 'python3' for auto-detection of workspace `.venv`. Explicit path overrides auto-detection. Must have `cognee` and `python-dotenv` installed."
        },
        "cogneeMemory.logLevel": {
          "type": "string",
          "enum": [
            "error",
            "warn",
            "info",
            "debug"
          ],
          "default": "info",
          "description": "Logging verbosity level"
        }
      }
    }
  },
  "scripts": {
    "vscode:prepublish": "npm run compile",
    "compile": "node esbuild.js --production",
    "compile:tests": "tsc -p tsconfig.test.json && cp src/test/run-test-agent.js out/test/",
    "pretest": "npm run compile:tests",
    "watch": "node esbuild.js --watch",
    "lint": "eslint src --ext ts",
    "test": "node ./out/test/runTest.js",
    "test:bridge": "cd bridge && pytest tests/ -v",
    "test:agent": "npm run compile:tests && node ./out/test/run-test-agent.js",
    "test:all": "npm test && npm run test:bridge",
    "package": "vsce package",
    "verify:vsix": "node scripts/verify-vsix.js *.vsix"
  },
  "devDependencies": {
    "@types/chai": "^5.2.3",
    "@types/glob": "^8.1.0",
    "@types/mocha": "^10.0.10",
    "@types/mock-fs": "^4.13.4",
    "@types/node": "^20.19.24",
    "@types/sinon": "^17.0.4",
    "@types/vscode": "^1.105.0",
    "@typescript-eslint/eslint-plugin": "^6.21.0",
    "@typescript-eslint/parser": "^6.21.0",
    "@vscode/test-electron": "^2.5.2",
    "chai": "^6.2.1",
    "esbuild": "^0.19.12",
    "eslint": "^8.57.1",
    "glob": "^11.0.3",
    "mocha": "^11.7.5",
    "mock-fs": "^5.5.0",
    "sinon": "^21.0.0",
    "ts-node": "^10.9.2",
    "typescript": "^5.9.3"
  },
  "author": "RecallFlow Team",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/lsalsich/cognee.git"
  },
  "bugs": {
    "url": "https://github.com/lsalsich/cognee/issues"
  },
  "homepage": "https://github.com/lsalsich/cognee/tree/main/extension"
}
