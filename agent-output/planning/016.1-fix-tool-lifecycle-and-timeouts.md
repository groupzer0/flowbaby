# Plan 016.1: Fix Tool Lifecycle and Bridge Timeouts

**Plan ID**: 016.1
**Target Release**: v0.3.2 (hotfix)
**Created**: 2025-11-19
**Status**: Planning
**Epic Alignment**: Epic 0.3.0.3 - Agent-Driven Memory Integration (completion)
**Parent Plan**: Plan 016 (Agent Retrieval and UI-Visible Extension Tools)
**Related QA**: `qa/016-agent-retrieval-and-ui-visible-extension-tools-qa.md`

---

## Value Statement and Business Objective

As a developer using Cognee tools in GitHub Copilot,
I want the tool toggles in Configure Tools to accurately reflect whether tools are enabled, and I want the tools to work reliably without timing out,
So that I can trust the privacy controls and successfully store/retrieve memories during agent conversations.

**Success Criteria**:

- Disabling a tool in Configure Tools immediately removes it from the available tools list
- `#cognee*` commands disappear from autocomplete when tools are disabled
- Bridge operations (`ingest.py`, `retrieve.py`) complete within their timeout budgets
- Manual round-trip storeâ†’retrieve workflow succeeds without errors

---

## Objective

Fix critical bugs discovered during Plan 016 QA that prevent tools from being usable:

1. **Tool Lifecycle Bug**: Disabling tools via Configure Tools or unchecking `cogneeMemory.agentAccess.enabled` leaves tool checkboxes enabled and `#cognee*` commands visible, even though invocation correctly fails. Users cannot trust the UI to reflect actual privacy state.

2. **Bridge Timeout Issues**: Both `retrieve.py` and `ingest.py` consistently timeout (15s and 120s respectively), preventing any successful memory storage or retrieval even when tools are enabled. **Key Insight**: Normal ingestion operations take 45-60 seconds, so a timeout at 120 seconds indicates the timeout is likely a **symptom of an underlying error** that isn't being surfaced properly, not the root problem itself.

3. **Architectural Simplification**: **Completely remove** `cogneeMemory.agentAccess.enabled` workspace setting, the `AgentAccessStatusBar`, and ALL related logic. Adopt VS Code best practices: tie tool availability and command enablement exclusively to whether tools are enabled via Configure Tools UI. Keep it simpleâ€”no additional authorization layers beyond what VS Code provides natively.

**Dependencies**:

- Plan 016 marked as **partially complete** (implementation exists but has critical bugs preventing release)
- QA report documents the failures: `qa/016-agent-retrieval-and-ui-visible-extension-tools-qa.md`
- This plan (016.1) supersedes Plan 016 for release purposesâ€”016 will remain incomplete until 016.1 fixes are merged

**Out of Scope**:

- New features or capabilities beyond fixing the identified bugs
- Changes to the bridge contract or structured summary schema
- Enhancements to transparency indicators or status bar (existing functionality must continue working)

---

## Problem Analysis

QA testing of Plan 016 revealed three critical bugs that prevent the tools from being usable. Below is a detailed analysis of each bug with reproduction steps, hypotheses, and proposed fixes.

### Bug 1: Tool Lifecycle UI Desync (P0 - Privacy Impact)

**Status**: Confirmed via manual testing  
**Severity**: P0 (users cannot trust privacy controls)  
**Category**: UI/UX Bug

**Symptom**:

When users disable Cognee tools (either by unchecking the workspace setting `cogneeMemory.agentAccess.enabled` OR by toggling tools off in Configure Tools UI), the UI does not reflect the change:

- Tool checkboxes in Configure Tools remain visually enabled/checked
- `#cognee*` commands remain visible in autocomplete suggestions
- Backend enforcement works correctly (invocations fail with access-denied errors)
- Status bar continues showing "Agent Access: Enabled"

**Impact**:

Users cannot visually confirm whether tools are enabled/disabled, creating:

1. **Privacy confusion**: Users think tools are on when they're off (or vice versa)
2. **Trust erosion**: UI contradicts actual behavior, making system feel unreliable
3. **Documentation problems**: Can't screenshot "disabled state" because UI shows "enabled"

**Steps to Reproduce**:

1. Open VS Code with Cognee extension installed
2. Open Configure Tools in Copilot Chat
3. Verify both Cognee tools show as enabled (checked)
4. Go to Settings â†’ Extensions â†’ Cognee Memory
5. Uncheck `cogneeMemory.agentAccess.enabled`
6. Return to Configure Tools
7. **Expected**: Tool checkboxes unchecked, tools absent from `#cognee*` autocomplete
8. **Actual**: Tool checkboxes still checked, `#cognee*` still suggests commands

**Root Cause Hypothesis**:

The implementation in `extension.ts` correctly calls `dispose()` on tool registrations when the setting changes:

```typescript
// Line 150-161 in extension.ts
if (!newEnabled && (storeMemoryToolDisposable || retrieveMemoryToolDisposable)) {
    if (storeMemoryToolDisposable) {
        storeMemoryToolDisposable.dispose();
        storeMemoryToolDisposable = undefined;
    }
    if (retrieveMemoryToolDisposable) {
        retrieveMemoryToolDisposable.dispose();
        retrieveMemoryToolDisposable = undefined;
    }
    outputChannel.appendLine('ðŸ”’ Language model tools unregistered (agent access disabled)');
}
```

However, VS Code's Configure Tools UI may:

- Cache tool metadata and not refresh when disposables are disposed
- Require an explicit refresh signal we're not sending
- Only update UI on window reload/extension restart
- Have a timing issue where UI reads tool list before disposal completes

**Proposed Fix**:

See Milestone 1 for architectural solution (remove workspace setting entirely, rely solely on Configure Tools UI).

Alternative technical fixes if keeping setting:

1. Force VS Code UI refresh after tool disposal (if API exists)
2. Delay tool registration until user explicitly enables via Configure Tools
3. Add visual indicator in tool metadata warning users to check workspace settings

---

### Bug 2: Python Bridge Timeouts (P0 - Functionality Blocker)

**Status**: Consistently reproducible  
**Severity**: P0 (core functionality completely broken)  
**Category**: Runtime/Performance Bug

**Symptom**:

Both `ingest.py` and `retrieve.py` bridge scripts consistently timeout, preventing any memory storage or retrieval:

- `retrieve.py` times out after 15 seconds (100% of attempts)
- `ingest.py` times out after 120 seconds (100% of attempts)
- No partial results returned; complete failure
- Errors appear in Output channel but user sees no actionable guidance

**Impact**:

1. **Zero functionality**: Users cannot store or retrieve any memories
2. **Silent failure**: Tools appear enabled but do nothing useful
3. **Poor error messages**: Generic timeout without diagnosis
4. **Blocked workflows**: Manual QA cannot proceed; no way to test storeâ†’retrieve

**Critical Observation**:

Normal ingestion operations typically complete in 45-60 seconds based on historical behavior. The fact that `ingest.py` timed out at exactly 120 seconds (2x normal duration) strongly suggests the **timeout is a symptom, not the root cause**. An underlying error is likely occurring that:

- Is not being surfaced to the user or Output channel
- Causes the script to hang or retry indefinitely
- Eventually hits the hard timeout limit

The diagnostic priority should be identifying and surfacing the hidden error, not simply increasing timeout values.

**Error Messages**:

Retrieve timeout (2025-11-19 21:27:46 UTC):

```text
[2025-11-19T21:27:46.305Z] [ERROR] Python script timeout {"script":"retrieve.py","timeout":15000,"elapsed_ms":15011}
[2025-11-19T21:27:46.305Z] [ERROR] Retrieval exception {"duration":15011,"error":"Python script timeout after 15 seconds"}
```

Ingest timeout (2025-11-19 20:54:53 UTC):

```text
[2025-11-19T20:54:53.470Z] [ERROR] Python script timeout {"script":"ingest.py","timeout":120000,"elapsed_ms":120016}
[2025-11-19T20:54:53.471Z] [ERROR] Summary ingestion timeout {"topic":"QA Findings - Tool Lifecycle and Access Control Regressions","duration_ms":120017,"error_type":"timeout","error":"Python script timeout after 120 seconds","note":"Summary ingestion may still complete in background - check @cognee-memory retrieval"}
```

**Root Cause Hypotheses**:

Ordered by likelihood based on available evidence:

#### Hypothesis A: LLM API Issues (High Probability)

**Evidence**:

- `.env` contains `LLM_API_KEY=sk-proj-...` (OpenAI key format)
- Cognee SDK makes LLM calls during ingestion (cognify pipeline)
- Both scripts timeout at hard limits (15s, 120s) suggesting wait-for-response loops
- No intermediate progress logs suggesting hang during external call

**Diagnostic Tests**:

1. Verify API key validity: `curl https://api.openai.com/v1/models -H "Authorization: Bearer $LLM_API_KEY"`
2. Check for rate limiting: Inspect response headers for `x-ratelimit-remaining`
3. Test standalone LLM call latency from same environment

**Likely Fix**:

- If key expired: Update `.env` with fresh key
- If rate limited: Wait for reset or use different tier
- If API slow: Increase timeouts (retrieve: 60s, ingest: 300s)

#### Hypothesis B: Cognee 0.4.0 File Hashing Bug (Medium Probability)

**Evidence**:

- CHANGELOG explicitly mentions: "Known Issues: Cognee 0.4.0 file hashing bug affects auto-ingestion"
- Bug is known and documented but not yet worked around in our code
- File hashing could block subprocess indefinitely if it encounters large files or permission issues

**Diagnostic Tests**:

1. Run `ingest.py` standalone with minimal test data
2. Monitor process with `strace` to see if stuck in file I/O syscalls
3. Check workspace for large files that might trigger hashing

**Likely Fix**:

- Upgrade Cognee SDK to version with fix (if available)
- Add workaround flag to skip file hashing if Cognee exposes config
- Limit ingestion to text-only (no file attachments) until fixed

#### Hypothesis C: Subprocess Management Bug (Low Probability)

**Evidence**:

- Timeouts are deterministic (always exactly 15s/120s)
- Suggests `CogneeClient` subprocess wait is hitting configured timeout, not variable hang
- If subprocess management broken, we'd expect zombie processes or resource exhaustion

**Diagnostic Tests**:

1. Check for orphaned Python processes: `ps aux | grep -E '(ingest|retrieve).py'`
2. Inspect `CogneeClient.ts` timeout logic and subprocess kill handling
3. Verify stderr/stdout pipes don't block

**Likely Fix**:

- Ensure subprocess.kill() is called on timeout
- Add subprocess.stdin.end() to prevent pipe blocking
- Increase buffer size for stdout/stderr if output is large

#### Hypothesis D: Ontology Loading Performance (Low Probability)

**Evidence**:

- `ontology.ttl` must be parsed by RDFLib on every script invocation
- Large ontologies (>1MB) can take seconds to parse
- However, 15s/120s seems too long for even large ontologies

**Diagnostic Tests**:

1. Time ontology loading: `python -c "from rdflib import Graph; import time; start=time.time(); g=Graph(); g.parse('ontology.ttl'); print(time.time()-start)"`
2. Check ontology file size and complexity

**Likely Fix**:

- Cache loaded ontology graph in memory (requires persistent daemon)
- Serialize ontology to faster format (pickle, JSON-LD)
- Optimize ontology (remove redundant triples)

**Steps to Reproduce**:

1. Enable Cognee tools in Configure Tools
2. Attempt to store summary via `#cogneeStoreSummary` tool
3. Wait 120 seconds
4. Observe timeout error in Output channel
5. Attempt to retrieve via `#cogneeRetrieveMemory` tool with any query
6. Wait 15 seconds
7. Observe timeout error in Output channel

**Proposed Fix**:

See Milestone 2 for diagnostic and fix strategy.

---

### Bug 3: Redundant Authorization Layer (P1 - UX Complexity)

**Status**: Design issue identified by user  
**Severity**: P1 (confusing but not blocking if understood)  
**Category**: Architectural/UX Issue

**Symptom**:

Plan 016 implemented two separate authorization mechanisms:

1. **Workspace setting**: `cogneeMemory.agentAccess.enabled` (on/off for entire workspace)
2. **Configure Tools UI**: Per-tool enable/disable toggles

Having both creates confusion because:

- Users must enable BOTH the workspace setting AND the tool toggles
- Disabling one but not the other leads to unexpected behavior
- Documentation must explain two separate concepts
- No additional security value (both mechanisms achieve same goal: user opt-in)

**Impact**:

1. **Cognitive overhead**: Users must understand and manage two authorization layers
2. **Error-prone**: Easy to toggle one but forget the other
3. **Documentation burden**: README must explain when to use each mechanism
4. **Support cost**: Users file bugs when tools don't work because setting is off but toggles are on

**User Feedback**:

> "I think that now that we are explicitly enabling and disabling the tools in the chat tool kit, we can remove the cogneeMemory.agentAccess.enabled setting entirely. It's an added level of security that isn't needed now, and it causes confusion."

**Original Rationale (Plan 016)**:

The workspace setting was added because:

- "VS Code does not expose caller extension IDs" so can't do per-extension authorization
- Wanted explicit workspace-global opt-in with prominent privacy warnings
- Follows principle: "default disabled, user must explicitly enable"

However, Configure Tools UI already provides workspace-global opt-in:

- When users enable Cognee tools there, they're explicitly granting access
- VS Code shows clear UI for enabling/disabling tools
- No additional setting needed

**Proposed Fix**:

See Milestone 1: Remove `cogneeMemory.agentAccess.enabled` setting entirely, rely solely on Configure Tools UI.

---

## Plan

### Milestone 1: Remove Redundant Workspace Setting

**Objective**: Simplify authorization to rely solely on VS Code's Configure Tools UI, eliminating `cogneeMemory.agentAccess.enabled` and its related complexity.

**Tasks**:

1. **Update `package.json` Configuration**
   - Remove `cogneeMemory.agentAccess.*` settings from configuration section
   - Keep other settings (`cogneeMemory.enabled`, timeout configs, etc.) unchanged
   - **Acceptance**: `package.json` no longer defines workspace-level agent access settings

2. **Update Tool Registration Logic in `extension.ts`**
   - Modify `registerLanguageModelTool()` to unconditionally register both tools at activation (no setting check)
   - Remove the `onDidChangeConfiguration` listener for `agentAccess.enabled`
   - Remove conditional registration/unregistration logic
   - **Rationale**: VS Code's Configure Tools UI becomes the sole source of truth; users enable/disable tools there
   - **Acceptance**: Tools register at activation without checking any workspace setting

3. **Remove Access Control Checks from Tools**
   - In `StoreMemoryTool.invoke()` and `RetrieveMemoryTool.invoke()`, remove the check for `cogneeMemory.agentAccess.enabled`
   - Tools should assume if they're invoked, the user has enabled them via Configure Tools UI
   - Keep audit logging (Output channel) for transparency
   - **Acceptance**: Tools invoke without checking workspace settings; rely on VS Code tool system for authorization

4. **Update Command Access Control to Check Configure Tools State**
   - In `ingestForAgent.ts` and `retrieveForAgent.ts`, replace `cogneeMemory.agentAccess.enabled` checks with Configure Tools enablement state
   - Commands must consult `vscode.lm.tools` enablement API or maintain cached state from tool enablement listeners
   - If tools are disabled, commands fail fast with `AGENT_ACCESS_DISABLED` error code and clear message
   - Keep audit logging for all invocations (both successful and rejected)
   - **Acceptance**: Commands check Configure Tools state; rejected calls logged with error code

5. **Remove `AgentAccessStatusBar` Completely**
   - Delete `extension/src/statusBar/agentAccessStatusBar.ts` file
   - Remove all imports and references to `AgentAccessStatusBar` in `extension.ts`
   - Remove status bar item from `deactivate()` cleanup
   - **Rationale**: Status bar was tied to `agentAccess.enabled` setting; with setting removed, there's no meaningful state to display. VS Code Configure Tools UI already provides visual feedback for tool enablement.
   - **Acceptance**: Status bar code completely removed; extension compiles without errors

6. **Update Documentation**
   - Remove references to `cogneeMemory.agentAccess.enabled` from README.md, AGENT_INTEGRATION.md
   - Update to explain: "Enable Cognee tools via Configure Tools UI in GitHub Copilot Chat"
   - Simplify privacy messaging: "Cognee tools are workspace-specific and store data locally"
   - **Acceptance**: Documentation reflects new simplified authorization model

7. **Update Tests and Verify Complete Removal**
   - Remove or update tests that toggle `cogneeMemory.agentAccess.enabled`
   - Tool lifecycle tests should verify registration at activation, not based on settings
   - Access control tests should be removed (no setting to enforce)
   - **Required**: Run repository-wide grep for `agentAccess.enabled` and `AgentAccessStatusBar` to ensure no lingering references
   - Key test areas to review: `extension/src/test/**/*tool*.test.ts`, `extension/src/test/**/*agent*.test.ts`, `extension/src/test/**/*command*.test.ts`
   - **Acceptance**: Test suite passes without references to removed setting; grep returns zero matches for `cogneeMemory.agentAccess.enabled` in source files

**Owner**: Implementer  
**Dependencies**: None (bug fix can proceed immediately)  
**Validation**: Tools register unconditionally; no workspace setting checks; documentation updated

---

### Milestone 2: Diagnose and Fix Bridge Timeouts

**Objective**: Identify why `ingest.py` and `retrieve.py` timeout and implement fixes so operations complete successfully.

**Tasks**:

1. **Validate LLM API Key and Connectivity**
   - Test the API key from `.env` with a simple curl command or Python script
   - Verify OpenAI API is reachable and responding within reasonable time (<5s)
   - Check for rate limiting or account issues
   - **Acceptance**: Confirm API key works and OpenAI responds quickly

2. **Add Diagnostic Logging and Error Surfacing to Bridge Scripts**
   - Update `ingest.py` and `retrieve.py` to emit progress logs:
     - "Starting ingestion/retrieval"
     - "Loaded ontology"
     - "Calling cognee.add / cognee.search"
     - "Waiting for LLM response"
     - "Received response, processing"
   - **Critical**: Wrap all operations in try/except blocks and emit structured error payloads to stderr: `{"error_code": "<CODE>", "error_type": "<TYPE>", "message": "<MSG>", "traceback": "<TRACE>"}`
   - Define minimal error code taxonomy for this hotfix:
     - `LLM_API_ERROR` - OpenAI authentication/rate-limit/timeout failures
     - `COGNEE_SDK_ERROR` - Cognee 0.4.0 file hashing or ingestion failures
     - `PYTHON_ENV_ERROR` - Missing dependencies or environment issues
     - `ONTOLOGY_LOAD_ERROR` - RDFLib parsing failures
   - Ensure TypeScript `CogneeClient` captures and logs ALL stderr output with error codes visible in Output channel
   - **Rationale**: Timeouts at 120s (2x normal duration) suggest underlying errors are being swallowed; must surface hidden failures with actionable codes
   - **Acceptance**: Bridge scripts emit timestamped progress markers AND structured error payloads with error codes for all failures

3. **Test Bridge Scripts Standalone**
   - Run `python extension/bridge/ingest.py` manually with test data
   - Run `python extension/bridge/retrieve.py` manually with test query
   - Measure actual execution time
   - Identify where time is spent (ontology load, LLM call, file I/O, etc.)
   - **Acceptance**: Standalone execution completes or reveals specific blocking operation

4. **Implement Fixes Based on Diagnosis**
   - **Priority 1: Surface Hidden Errors**: Ensure all bridge exceptions are captured and displayed in Output channel with full context
   - **Priority 2: Fix Root Cause**: Address the underlying error identified through diagnostic logging:
     - **If LLM API error**: Fix authentication, handle rate limits gracefully, provide actionable user message
     - **If Cognee SDK error**: Upgrade to newer version, add workaround, or document limitation
     - **If configuration error**: Add validation and clear error messages for missing/invalid settings
   - **Priority 3: Adjust Timeouts (only if justified)**: If diagnosis proves operations legitimately take longer than budgeted, increase timeouts (retrieve: 15s â†’ 60s, ingest: 120s â†’ 180s). **Do not increase timeouts without identifying root cause first.**
   - **Acceptance**: Bridge operations complete successfully OR fail with clear, actionable error messages (no silent hangs)

5. **Verify Round-Trip Workflow**
   - Manually test: Enable tools â†’ Store summary via tool â†’ Retrieve via query
   - Verify Output channel shows successful completion without timeout errors
   - Verify returned results match stored summary
   - **Acceptance**: Manual round-trip succeeds end-to-end

**Owner**: Implementer  
**Dependencies**: Milestone 1 (simplified tool registration so tests don't fight with settings)  
**Validation**: Bridge scripts complete within timeouts; manual storeâ†’retrieve succeeds

---

### Milestone 3: Update Tests and QA Validation

**Objective**: Update test suite to reflect new authorization model and verify all Plan 016 acceptance criteria pass.

**Tasks**:

1. **Update Integration Tests**
   - Remove `toolIntegration.test.ts` tests that toggle `agentAccess.enabled`
   - Add tests verifying tools register at activation
   - Keep round-trip tests but remove setting manipulation
   - **Acceptance**: Integration tests pass without setting dependencies

2. **Update Unit Tests**
   - Remove access-disabled checks from `StoreMemoryTool.test.ts` and `RetrieveMemoryTool.test.ts`
   - Focus on tool invocation logic, error handling, response formatting
   - **Acceptance**: Unit tests pass; focus on tool behavior not authorization

3. **Remove `agentIngestion.integration.test.ts` Access Control Tests**
   - Tests that verify `config.update('agentAccess.enabled', ...)` are obsolete
   - Keep tests that verify ingestion/retrieval success paths
   - **Acceptance**: Ingestion tests pass without setting checks

4. **Execute Manual QA Checklist**
   - Open Configure Tools in Copilot Chat
   - Enable Cognee Store/Retrieve tools via toggles
   - Verify tools appear in `#cognee*` autocomplete
   - Store a test summary via tool
   - Retrieve summary via query
   - Disable tools via toggles
   - Verify tools disappear from `#cognee*` autocomplete
   - Verify Output channel shows operation logs (transparency surface)
   - **Acceptance**: All manual scenarios pass; Configure Tools UI accurately reflects tool state; Output channel provides operation visibility

5. **Update QA Report**
   - Document passing test results
   - Confirm all Plan 016 acceptance criteria met after fixes
   - Mark QA status as "Passed"
   - **Acceptance**: QA report shows green status

**Owner**: QA + Implementer  
**Dependencies**: Milestones 1-2 complete  
**Validation**: Automated tests pass; manual QA checklist completes successfully; QA report updated

---

### Milestone 4: Update Version and Documentation

**Objective**: Document changes in CHANGELOG and update version for hotfix release.

**Tasks**:

1. **Update CHANGELOG**
   - Add v0.3.2 (or v0.3.3 if 0.3.2 already released) entry:
     - **Fixed**: Tool lifecycle bug - Configure Tools toggles now accurately reflect tool registration state
     - **Fixed**: Bridge timeout issues - surfaced hidden errors and improved error reporting instead of silent hangs
     - **Removed**: `cogneeMemory.agentAccess.enabled` workspace setting and `AgentAccessStatusBar` - tool authorization now exclusively via VS Code Configure Tools UI (following VS Code best practices)
     - **Changed**: Simplified architecture - tools and commands enabled/disabled solely through VS Code native mechanisms
   - **Acceptance**: CHANGELOG reflects all Plan 016.1 changes

2. **Update README**
   - Simplify "Using Cognee Tools with Custom Agents" section
   - Remove references to workspace setting
   - Emphasize Configure Tools UI as sole control mechanism
   - **Acceptance**: README accurately describes new workflow

3. **Update AGENT_INTEGRATION.md**
   - Remove workspace setting from integration guide
   - Update error code documentation (remove `ACCESS_DISABLED` if no longer applicable)
   - Simplify authorization story: "Tools register at activation; users enable via Configure Tools"
   - **Acceptance**: Integration docs reflect new model

4. **Update Architecture Documentation**
   - Verify `agent-output/architecture/system-architecture.md` reflects Configure Tools-only model (architect has already updated Â§4.5)
   - Confirm architecture diagram (`system-architecture.mmd`) no longer references status bar
   - Add note to Â§8 Known Problem Areas that agentAccess setting and status bar are removed as of v0.3.2
   - **Acceptance**: Architecture docs consistent with implementation

5. **Commit Changes**
   - Commit message: "Hotfix v0.3.2 - Fix tool lifecycle and bridge timeouts (Plan 016.1)"
   - Include all fixes: tool registration, bridge timeouts, documentation, architecture alignment
   - **Acceptance**: Clean commit ready for release

**Owner**: Implementer  
**Dependencies**: Milestones 1-3 complete  
**Validation**: Documentation accurate; version artifacts updated

---

## Testing Strategy

**Unit Tests**:

- Tool invocation logic (without access checks)
- Response formatting and error handling
- Command JSON parsing and response serialization

**Integration Tests**:

- Tool registration at activation
- Round-trip storeâ†’retrieve workflow
- Bridge contract tests (ensure structured responses still work)

**Manual Tests**:

- Configure Tools UI: enable/disable toggles and verify `#cognee*` autocomplete behavior
- Store summary via tool: verify success without timeout
- Retrieve summary via query: verify results returned without timeout
- Transparency indicators: verify Output channel logs activity

**QA Acceptance**:

- All automated tests pass
- Manual QA checklist completes successfully
- No timeout errors in Output channel during workflows

---

## Risks

1. **VS Code Tool UI Behavior Uncertain**
   - Risk: We assume disposing tool registrations updates Configure Tools UI immediately, but this may not be true
   - Mitigation: Test with VS Code 1.106+ to verify behavior; if disposal doesn't update UI, investigate VS Code API alternatives or file bug report
   - **Impact**: If UI doesn't update, users may still see stale state (though backend enforcement will work)

2. **Bridge Timeout Root Cause Unknown**
   - Risk: Without diagnosing the exact cause, we may apply wrong fix (e.g., increase timeout when real issue is hung subprocess)
   - Mitigation: Milestone 2 includes diagnostic logging and standalone testing to identify specific blocking operation
   - **Impact**: If diagnosis is wrong, timeouts may persist after changes

3. **Authorization Regression**
   - Risk: Removing workspace setting may create perception that tools are "always on" and reduce user control
   - Mitigation: Configure Tools UI provides clear enable/disable controls; documentation emphasizes user choice
   - **Impact**: Users must learn new authorization model (Configure Tools) but net UX is simpler

4. **Test Suite Churn**
   - Risk: Updating many tests to remove setting checks may introduce new bugs or break coverage
   - Mitigation: Focus on simplifying tests (remove conditional logic); keep core behavior tests intact
   - **Impact**: Short-term test instability but long-term simpler test maintenance

---

## Validation

**Milestone Acceptance**:

- âœ… **Milestone 1**: `cogneeMemory.agentAccess.enabled` removed from code, tests, docs; tools register unconditionally
- âœ… **Milestone 2**: Bridge operations complete without timeouts; manual storeâ†’retrieve succeeds
- âœ… **Milestone 3**: Test suite passes; manual QA checklist completes successfully; QA report shows "Passed"
- âœ… **Milestone 4**: CHANGELOG, README, AGENT_INTEGRATION updated; commit created

**Plan Success**:

- Users can enable/disable Cognee tools via Configure Tools UI
- Tool toggles and `#cognee*` autocomplete accurately reflect tool registration state
- Store and retrieve operations complete successfully without timeouts
- Manual round-trip workflow succeeds end-to-end
- Documentation is clear and accurate
- QA report shows all tests passing

---

## Open Questions

1. **Status Bar Future**: ~~Should we keep `AgentAccessStatusBar`?~~ **RESOLVED**: Remove completely per user direction. VS Code Configure Tools UI provides sufficient visual feedback for tool state. Output channel logs provide transparency for operations.

2. **Error Code Taxonomy**: With `ACCESS_DISABLED` code removed, should we update the error taxonomy doc created in Plan 016?
   - **Recommendation**: Yes, update `AGENT_INTEGRATION.md` to remove `ACCESS_DISABLED` from error code reference table

3. **Timeout Budget Values**: What are appropriate timeouts for `ingest.py` (currently 120s) and `retrieve.py` (currently 15s) given real-world LLM latency?
   - **Recommendation**: After diagnosis, adjust based on p95 latency: retrieve 60s (4x current), ingest 300s (2.5x current) to account for large summaries

4. **Backward Compatibility**: Should we preserve `cogneeMemory.agentAccess.enabled` as deprecated setting for one release cycle?
   - **Recommendation**: No, clean break is simpler. Users on v0.3.1 can migrate directly to v0.3.2 with updated docs

---

## References

- `agent-output/planning/016-Agent-retrieval-and ui-visible-extension-tools.md` (parent plan)
- `agent-output/qa/016-agent-retrieval-and-ui-visible-extension-tools-qa.md` (QA report documenting bugs)
- `agent-output/architecture/system-architecture.md` (Â§4.5 agent integration architecture, updated 2025-11-19)
- `agent-output/architecture/016.1-fix-tool-lifecycle-and-timeouts-architecture-findings.md` (architectural review)
- `agent-output/critiques/016.1-fix-tool-lifecycle-and-timeouts-critique.md` (critic review)
- `extension/src/extension.ts` (tool registration logic)
- `extension/src/tools/storeMemoryTool.ts`, `extension/src/tools/retrieveMemoryTool.ts` (tool implementations)
- `extension/bridge/ingest.py`, `extension/bridge/retrieve.py` (Python bridge scripts)

---

**Status**: Architectural Review Complete - Ready for Implementation
**Architectural Verdict**: APPROVED_WITH_NOTES (see architecture findings document)
**Next Steps**: Begin implementation with Milestone 1; architecture documentation already updated to reflect Configure Tools-only model
